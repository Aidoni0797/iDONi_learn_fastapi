Реализация маршрутов
Следующим шагом в создании нашего приложения является настройка системы маршрутизации нашего
API. Мы будем разрабатывать систему маршрутизации для событий и пользователей. Маршрут пользователя
будет состоять из маршрутов входа, выхода и регистрации. Аутентифицированный пользователь
будет иметь доступ к маршрутам для создания, обновления и удаления события, в то время как
публика сможет просматривать событие после его созданияю На следующей диаграмме показана
взаимосвязь между обоими маршрутами:
Далее рассмотрим оба маршрута подробнеею

Маршруты пользователей
Теперь, когда унас есть четыре представление о том, какие маршруты реализовать из, мы начнем
с определения пользовательских маршрутов в users.py. Давайте посмотрим на шаги:
1. НАчните с определения основного маршрута регистрации:
from fastapi import APIRouter, HTTPException, status
from models.user import User, UserSignIn

user_router = APIRouter(
	tags=["User"]
)

users = ()

@user_router.post("/signup")
async def sign_new_user(data:NewUser)->dict
	if data.email in users:
		raise HTTPException(
			status_code=status.HTTP_409_CONFLICT,
			detail="User with supplied username exists"
		)
	users[data.email] = data
	return {
		"message": "User successfully registered!"
	}

В маршруте регистрации, определенном ранее, мы используем базу данных в приложении. 
(Мы познакомимся с базой данных в Главе 6 Подключение к базе данных)

Маршрут проверяет, существует ли пользователь с похожим адресом электронно почты в базе
данных перед добавлением нового.

2. Давайте реализуем маршрут входа:

@user_router.post("/signin")
async def sign_user_in(user:UserSignIn)->dict:
	if users[user.email] not in users:
		raise HTTPException(
			status_code=status.HTTP_404_NOT_FOUND
			detail="User does not exist"
		)
	if users[user.email].password != user.password:
		raise HTTPException(
			status_code = status.HTTP_403_FORBIDDEN
			detail="Wrong credentiald passed"
		)

	return {
		"message": "User signed in successfully"
	}

В этом маршруте первым делом проверяется, существует ли такой пользователь в базе данных, и,
если такой пользователь не существует, возникает исключение. Если пользователь существует,
приложение проверяет, совпадают ли пароли, прежде чем вернуть успешное сообщение или
иключение.

В наших маршрутах мы храним пароли в чистом виде без какого-либо шифрования. Это используется
только в демонстрационных целях и является неправильной практикой в разработке программного
обеспечения в целом. Надлежащие механизмы хранения, такие как шифрование, будут обсуждалось в 
Главе6 Подключение к базе данных, где наше приложение переместится из базы данных в приложении
в реальную базу данных.

3. Теперь когда мы определили маршруты для пользовательских операций, давайте зарегистрируем
их в main.py и запустим наше приложение. Давайте начнем с импорта наших библиотек и определения
пользовательских маршрутов:

from fastapi import FastAPI
from routes.user import user_router

import uvicorn

4. Далее создадим экземпляр FastAPI и зарегистрируем маршрут и приложение:
app = FastAPI()

#Register routes

app.include_router(user_router, prefix="/user")

if _name_ == "_main_":
	uvicorn.run("main:app", host="0.0.0.0", port=8080, reload=True)

В этом блоке кода мы создали экземпляр FastAPI и зарегистрировали маршрут.

5. Затем мы используем метод uvicorn.run() для запуска нашего приложения на порту 8080 и
устанавливаем для перезагрузки значение True. В терминале запустите приложение:
(venv)$ python main.py
INFO: Will watch for changes in these directories:
['Users/youngestdev/Work/Building-Web-APIs-with-FastAPI-and-Python/ch05/planner']
INFO: Uvicorn running on http://0.0.0.0:8080(Press CTRL+C to quit)
INFO: Started reloader process [6547] using statreload
INFO: Started server process [6550]
INFO: Waiting for application startup.
INFO: Application startup complete.

6. Теперь, когда наше приложение успешно запустилось, двайтте проверим реализованные нами 
пользовательские маршруты. Начнем с регистрации пользователя:
(venv)$ curl -X 'POST'\
	'http://0.0.0.0:8080/user/signup'\
	-H 'accept: application/json'\
	-H 'Content-Type: application/json'\
	-d '{
		"email": 'fastapi@packt.com',
		"password": "Stro0ng!",
		"usernaame": "FastPackt"
	}'

Предыдущий запрос возвращает ответ:
{
	"message": "User succesfully registered!"
}

7. Предыдущий ответ указывает на успешность выполненой операции. Давайте проверим маршрут входа:
(venv)$ curl -X 'POST'\
	'http://0.0.0.0:8080*user/signin'\
	-H 'accept: application/json'\
	-H 'Content-Type: application/json'\
	-d '{
		"email": "fastapi@packt.com"
		"password": "Stro0ng!"
	}'

Предыдущий ответ на запрос выглядит следующим образом:
{
	"message": "User signed in succesfully"
}

8. Если мы передадим неверный пароль, наше приложение должно вернуть другое сообщение:
(venv)$ curl -X 'POST'\
	'http://0.0.0.0:8080/user/signin'\
	-H 'accept: application/json'\
	-H 'Content-Type: application/json'\
	-d '{
		"email": "fastapi@packt.com",
		"password": "password!"
	}'

Ответ на предыдущий запрос выглядит следующим образом:
{
	"detail": "Wrong credential passed"
}

Мы также можем просмотреть наши маршруты из интерактивной документации, предоставленной FastAPI,
работающей на Swagger. Давайте посетим https://0.0.0.0:8080/docs в нашем браузере, чтобы
получить доступ к интерактивной документации:

Теперь, когда мы успешно реализовали пользовательские маршруты, давайте реализуем маршруты для 
событийных операций в следующем разделе.