Создание Docker образа

Чтобы создать образ приложения, выполните следующую команду в базовом каталоге:
(venv)$ docker build -t event-planner-api .

Эта команда просто указывает Docker создать образ с тегом event-planner-api из инструкций,
определенных в текущем каталоге, который представлен точкой в конце команды. Процесс сборки
начинается после запуска команды и выполнения инструкций:

Теперь, когда мы успешно создали образ нашего приложения, давайте вытащим образ MongoDB:
(venv)$ docker pull mongo

Мы извлекаем образ MongoDB, чтобы создать автономный контейнер базы данных, доступный из 
контейнера API при создании. По умолчанию контейнер Docker имеет отдельную сетевую конфигурацию, 
и подключение к локальному адресу хостов машины запрещено.

Что такое docker pull?
Команда docker pull отвечает за загрузку образов из реестра. Если не указано иное, эти образы
загружаются из общедоступного реестра Docker Hub.

Развертывание приложения локально

Теперь, когда мы создали образы для API и загрузили образ для базы данных MongoDB,
давайте приступим к написанию манифеста для обработки развертывания нашего приложения.
Манифест docker-compose будет состоять из службы API и службы базы данных MongoDB.
В корневом каталоге создайте файл манифеста:
(venv)$ touch docker-compose.yml

Содержимое файла манифеста docker-compose будет следующим:
docker-compose.yml

version: "3"

services:
	api:
		build: .
		image: event-planner-api:latest
		ports:
			-"8080:8080"
		env_file:
			-.env.prod
	database:
		image: mongo
		ports:
			-"27017"
		volumes:
			-data:/data/db

volumes:
	data:

В разделе services у нас есть служба api и служба database. В службе api применяется 
следующий набор инструкций:

-Поле build указывает Docker на создание образа event-planner-api:latest для службы api
from file Dockerfile, расположенного в текущем каталоге обозначенном.

-Порт 8080 открыт из контейнера, чтобы мы могли получить доступ к службе через HTTP.

-Файл среды имеет значение .env.prod. Кроме того, переменные среды могут быть установлены 
в этом формате:

environment:
	-DATABASE_URL=mongodb://database:27017/planner
	-SECRET_KEY=secretkey

Этот формат в основном используется, когда переменные среды должны вводиться из службы
развертывания. Рекомендуется использовать файл окружения.

В службе database применяется следующий набор инстуркций:
-Служба database использует образ mongo, который мы получили ранее.

-Порт 27017 определен, но не доступен извне. Порт доступен только внутри службы api.

-К службе подключен постоянный том для хранения наших данных. Для этого выделена папка 
/data/db.

-Наконец, том мы поняли содержимое манифеста компоновки, давайте создадим файл среды,
.env.prod:

.env.prod

DATABASE_URL=mongodb://database:27017/planner
SECRET_KEY=NOTSTRONGENOUGH!

В файле среды DATABASE_URL задается именем службы MongoDB, созданной манифестом помпоновки.

Запускаем приложение
Мы настроены на развертывание и запуск приложеня из манифеста docker-compose. Давайте
запустим сервисы с помощью инструмента компоновки:
(venv)$ docker-compose up -d

Это команда запускаеи службы в автономном режиме:

Службы приложений созданы и развернуты. Давайте проверим, проверив список запущенных
контейнеров:
(venv)$docker ps

Результат выглядит следующим образом:

Команда возвращает список контейнеров, работающих вместе с портами, через которые к ним можно
получить доступ. Давайте проверим рабочее состояние, отправив запрос GET развернутому 
приложению:
(venv)$ curl -X 'GET'\
	'http://localhost:8080/event/'\
	-H 'accept: application/json'

Получаем следующий ответ:
[]

Замечательно! Развернутое приложение работает корректно. Давайте проверим, что база данных
также работает, создав пользователя:
(venv)$ curl -X 'POST'\
	'http://localhost:80080/user/signup'\
	-H 'accept: application/json' \ 
	-H 'Content-Type: application/json'\
	-d '{
	"email": "fastapi@packt.com",
	"password": "strong!!!"
	}'

Мы также поучаем положительный ответ:

{
	"message": "User creeated successfully"
}

Теперь, когда мы протестировали оба маршрута, вы можете приступить к тестированию других
маршрутов. Чтобы остановить сервер развертывания после проверки, из коневого каталога
запускается следующая команда:

(venv)$docker-compose down

Результат выглядит следующим образом: