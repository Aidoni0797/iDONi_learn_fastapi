Модульное тестирование с помощью pytest
Модульное тестирование - это процедура тестирования, при которой тестируются отдельные компоненты
приложения. Эта форма тестирования позволяет нам проверить работоспособность отдельных компонентов.
Например, модульные тесты используются для тестирования отдельных маршрутов в приложении,
чтобы убедиться, что возвращаются правильные ответы.

В этой главе мы будем использовать pytest, библиотеку тестирования Python, для проведения
наших операций модульного тестирования. Хотя Python поставляется со встроенной библиотекой
модульного тестирования под названием unittest билиотека, pytest имеет более короткий синтаксис
и более предпочтительна для тестирования приложений. Давайте установим pytest и напишем
наш  первый образец теста.

Давайте установим библиотеку pytest:
(venv)$pip install pytest

Затем создайте папку с именем tests, в которой будут храниться тестовые файлы для нашего
приложения:
(venv)$mkdir test && cd
(venv)$touch __init__.py

Имена отдельных тестовых модулей во время создания будут иметь префикс test_. Это позволит
библиотеке pytest распознать и запустить тестовый модуль. Создадим в только что созданном пакете 
tests тестовый модуль, пролверяющий правильность выполнения арифметических операций сложения,
вычитания, умножения и деления:
(venv)$ touch test_arthmetic_operations.py

Сначала определим функцию, которая выполняет арифметические операции. В модуле тестов добавьте следующее:
def add(a:int, b:int)->int:
	return a+b

def subtract(a:int, b:int)->int:
	return b-a

def multiply(a:int, b:int)->int:
	return a*b

def divide(a:int, b:int)->int:
	return b//a

Теперь, когда мы определили операции для тестирования, мы создадим функции, которые будут
обрабатывать эти тесты. В тестовых функциях определяется операция, которая должна быть выполнена.
Ключевое слово assert используется для проверки того, что вывод в левой части соответствует 
результат операции в правой части. В нашем случае мы будем проверять, равны ли арифматические операции
их соответствующим результатам.

Добавьте следующее в модуль tests:

def tes_add()->None:
	assert add(1,1)==2

def test_subtract()->None:
	assert subtract(2,5)==3

def test_multiply()->None:
	assert multiply(10,10)==100

def test_divide()->None:
	asser divide(25,100)==4

Совет
Стандартной практикой является определение функций, которые будут тестироваться во внешнем 
расположении (в нашем случае add(), subtract() и т.д.). Затем этот модуль импортируется,
и тестируемые функции вызываются в тестовых функциях.

Имея тестовые функции, мы готовы запустить тостовый модуль. Тесты можно выыполнить, выполнив
команду pytest. Однако эта команда запускает все тестовые модули, содержащиейся в пакете.
Для выполнения одного теста в качестве аргумента передается имя тестового модуля.
Запустим тестовый модуль:
(venv)$ pytest test_arthmetic_operations.py

Тесты определили все пролйдено. Об этом свидетельствует ответ, выделенный зеленым цветом:

Провалившиеся тесты, а также точка, сбоя выделены красным цветом.. Например, скажем, мы
модифицируем функцию test_add() как таковую:
def test_add()->None:
	assert add(1,1)==11

На средующем рисунке неудачный тест, а также точка отказа выделены красным цветом.

Тест не пройден в операторе assert, где отображается правильный результат 2.
Сбой резюмируется как AssertionError, что говорит нам о том, что тест не пройден из-за неверного 
утверждения (2==1)

Теперь, когда у нас есть представление о том, как работает pytest, давайте взглянем на фикстуры
в pytest.

Устранение повторений с помощью фикстур pytest
Фикстуры - это повторно используемые функции, определенные для возврата данных, необходимых
в тестовых функциях. Фикстуры оборачиваются декоратором pytest.fixture. Пример использования
фикстуры - возврат экземпляра приложения для выполнения тестов для конечных точек API.
Фикстура может использоваться для определения клиента приложения, который возвращается и
используется в тестовых функциях, что устраняет необходимость переопрделять экземпляр
приложения в каждом тесте. Мы увидим, как это используется в разделе "Написание тестов для
конечных точек REST API".

Давайте посмотрим на пример:
import pytest

from models.events import EventUpdate

#Fixture is defined.
@pytest.fixture
def event()->EventUpdate:
	return EventUpdat(
		title="FastAPI Book Launch",
		image="https://packt.com/fastapi.png",
		description="We will be discussing the contents of the FastAPI book in this event.
				Ensure to come with your own copy to win gifts!",
		tags=["python", "fastapi", "book", "launch"],
		location="Google Meet"
	)

def test_event_name(event:EventUpdate)->None:
	assert event.title =="FastAPI Book Launch"

В предыдущем блоке кода мы определили фикстуру, которая возвращает экземпляр pydantic models EventUpdate.
Это приспособление передается в качестве аргумента в функцию test_event_name, что позволяет
сделать свойства доступными.

Декоратор фикстуры может дополнительно принимать аругументы. Одним из этих аргументов является
область действия - область действия фикстуры сообщает pytest какова продолжительность функции
фикстуры.

В этой главе мы будем использовать две области видимости:

-session: Это область сообщает pytest, что нужно создать экземпляр функции один раз для
всего сеанса тестирования.
-module: Эта область инструктирует pytest выполнять добавленную функцию только после
выполнения тестового модуля.

Теперь, когда мы знаем, что такое фикстура, давайте настроим нашу тестовую среду в следующем
разделе.
