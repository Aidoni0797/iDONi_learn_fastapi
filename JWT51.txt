Создание и проверка токенов доступа
Создание JWT делает нас на шаг ближе к защите нашего приложения. Полезная нагрузка токена 
будет содержать идентификатор пользователя и время истечения срока действия перед
кодированием в длинную строку, как показано здесь:

Ранее мы узнали, почему JWT подписаны. JWT подписваются секретным ключом, известным
только отправителю и получателю. Давайте обновим класс Settings в модуле database/database.py,
а также файл среды, .env, включив в него переменную SECRET_KEY, которая будет использоваться
для подписи JWTs:

database/database.py

class Settings(BaseSettings):
	SECRET_KEY: Optional[str]=None

.env
SECRET_KEY = HI5HL3V3L$3CR3T

После этого добавьте следующий импорт в jwt_handler.py

import time
from datetime import datetime
from fastapi import HTTPException, status
from jose import jwt, JWTError
from database.database import Settings

В предыдущем блоке кода мы импортировали модули time, класс HTTPException, а также статус из
FastAPI. Мы также импортировали библиотеку jose отвечающую за кодирование и декодирование
JWT,  и класс Settings.

Далее мы создадим экземпляр класса Settings, чтобы мы могли получить переменную 
SECRET_KEY и создать функцию, отвечающую за создание токена:

settings = Settings()

def create_access_token(user:str)->str:
	payload = {
		"user": user,
		"expires": time.time() + 3600
	}
	token = jwt.encode(payload, settings.SECRET_KEY, algorithm = "HS256")
	return token

В предыдущем блоке кода функция принимает строковый аргумент, который передается в словарь
полезной нагрузки. Словарь полезной нагрузки содержит пользователя и время истечения строка 
действия, которое возвращается при декодировании JWT.

Срок действия устанавливается равны часу с момента создания. Затем полезная нагрузка передается
методу encode(), который принимает три параметра:
-Payload: Словарь, содержащий значения для кодирования.
-Key: Ключ, используемый для подписи полезной нагрузки.
-Algorithm: Алгоритм, используемый для подписи полезной нагрузки. По умолчанию и наиболее
распространенным является алгоритм HS256.

Далее давайте создадим функцию для проверки подлинности токена, отправленного в наше приложение:

def verify_access_token(token:str)->dict:
	try:
		data = jwt.decode(token, settings.SECRET_KEY, algorithm=["HS256"])
		expire = data.get("expires")
		
		if expire is None:
			raise HTTPException(
				status_code = status.HTTP_400_BAD_REQUEST,
				detail = "No access token supplied"
			)
		if datetime.utcnow()>
			datetime.utcfromtimestamp(expire):
				raise HTTPException(
					status_code = status.HTTP_403_FORBIDDEN,
					detail = "Token expired!"
				)
		return data
	except JWTError:
		raise HTTPException(
			status_code=status.HTTP_400_BAD_REQUEST,
			detail="Invalid token"
		)

В предыдущем блоке кода функция принимает в качестве аргумента строку токена и выполняет
несколько проверок в блоке try. Сначала функция проверяет срок действия токена. Если срок
действия не указан, значит, токен не был предоставлен. Вторая проверка - валидность токена -
генерируется исключение, информирующее пользвоателя об истечении срока действия токена.
Если токен действителен, возвращается декодированная полезная нагрузка.
В блоке except для любой ошибки JWT выдается исключение неверного запроса.
Теперь, когда мы реализовали функции для создания и проверки токенов, отправляемых в приложение,
давайте создадим функцию, которая проверяет футентификацию пользователя и служит зависимостью.
	