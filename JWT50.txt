Защита приложения с помощью OAuth2 and JWT
В этом разделе мы создадим систему аутентификации для приложения планировщика событий. Мы 
будем использовать поток паролей OAuth2, который требует от клиента отправки имени пользователя
и пароля в качестве данных формы. Имя пользователя в нашем случае - это электронная
почта, используемая при создании учетной записи.
Когда данные формы отправляются на сервер от клиента, в качестве ответа отправляется токен доступа,
который является подписанным JWT. Обычно выполняется фоновая проверка для проверки учетных
данных, отправленных на сервер, перед созданием токена для дальнейшей авторизации.
Чтобы авторизовать аутентифицированного пользователя, JWT имеет префикс Bearer при отправке через 
заголовок для авторизации действия на сервере.
Что такое JWT и почему он подписан?
JWT - это закодированная строка, обычно содержащая словарь, содержащий полезную нагрузку,
подпись и алгоритм. JWT подписываются с использованием уникального ключа, известного только
серверу и клиенту, чтобы избежать подделки закодированной строки внешним органом.
Теперь, когда у нас есть представление о том, как работает процесс аутентификации, давайте
создадим необходимую папку и файлы, необходимые для настройки системы аутентификации в нашем приложении:
1. В папке проекта сначала создайте папку auth:
(venv)$mkdir auth
2. Далее создайте  следующие файлы в папке auth:
(vrnv)$cd auth && touch(__init__, jwt_handler, authenticate, hash_password).py

Предыдущая комада создает четыре файла:
- jwt_handler.py: Этот модуль будет содержать функции, необходимые для кодирования и 
декодирования строк JWT.

- authenticate.py: Этот модуль будет содержать зависимость аутентификации, которая будет 
внедрена в наши маршруты для принудительной аутентификации и авторизации.

- hash_password.py: Этот модуль будет содержать функции, которые будут использоваться для
шифрования пароля пользователя при регистрации и сравнения паролей при входе.

- __init__.py: Этот файл указывает содержимое папки как пакет.

Теперь, когда файлы созданы, давайте создадим отдельные компоненты. Начнем с создания
компонентов для хеширования паролей пользователей.

Хэширование паролей

В предыдущей главе мы хранили пароли пользователей в виде обычного текста. Это очень
небезопасная и запрещенная практика при создании API. Пароли должны быть зашифрованы или
хешированы с использованием соответствующих библиотек. Мы будем шифровать пароли пользователей
с помощью bcrypt.

Давайте установим библиотеку passlib. В этой бибилиотеке находится алгоритм хеширования bcrypt,
который мы будем использовать для хэширования паролей пользователей:
(venv)$pip install passlib[bcrypt]

Теперь, когда мы установили библиотеку, давайте создадим функции для хеширования паролей в 
hash_password.py:

from passlib.context import CryptContext

pwd_context = CryptContext(schema=["bcrypt"], deprecated="auto")

class HashPassword:
	def create_hash(self, password:str):
		return pwd_context.hash(password)
	
	def verify_hash(self, plain_password:str, hashed_password:str):
		return pwd_context.verify(plain_password, hashed_password)

В предыдущем блоке кода мы начинаем с импорта CryptContext, который использует схему bcrypt
для хеширования переданных ему строк. Контекст хранится в переменной контекста pwd_context,
что дает нам доступ к методам, необходимым для выполнения нашей задачи.

Затем определяется класс HashPassword, который содержит два метода:
create_hash and verify_hash:

- Метод create_hash принимает строку и возвращает хеширование значение.
- verify_hash берет простой пароль и хешированный пароль и сравнивает их. Функция возвращает
логическое значение, указывающее, совпадают ли переданные значения или нет.

Теперь, когда мы создали класс для обработки хеширования паролей, давайте обновим маршрут
регистрации, чтобы хешировать пароль пользователя перед его сохранением в базе данных:

routes/users.py

from auth.hash_password import HashPassword
from database.connection import Database

user_database = Database(User)
hash_password = HashPassword()

@user_router.post("/signup")
async def sign_user_up(user:User)->dict:
	user_exist = await User.find_one(User.email == user.email)
	
	if user_exist:
		raise HTTPException(
			status_code = status.HTTP_409_CONFLICT,
			detail = "User with email provided exists already."
		)
	
	hashed_password = hash_password.create_hash(user.password)
	user.password = hashed_password
	
	await user_database.save(user)
	
	return {
		"message": "User created successfully"
	}

Теперь, когда мы обновили маршрут регистрации пользователя, чтобы хешировать пароль перед
сохранением, давайте создадим нового пользователя для подтверждения. В окне терминала 
запустите приложение:

(venv)$ python main.py
INFO: Uvicorn running on http://0.0.0.0:8080(Press CTRL+C to quit)
INFO: Started reloader process[8144] using startreload
INFO: Waiting for application startup.
INFO: Application startup complete.

В другом окне терминала запустите экземпляр MongoDB:
$mongodb --dbpath database --port 27017

Далее создадим нового пользователя:
$curl -X 'POST'\
	'http://0.0.0.0:8080/user/signup'\
	-H 'accept: application/json'\
	-H 'Content-Type: aplication/json'\
	-d '{
	"email": "reader@packt.com",
	"password": "exemplary"
	}'

Мы получаем успешный ответ на запрос выше:
{
	"message": "User created successfully"
}

Теперь, когда мы создали пользователя, давайте проверим, что пароль, отправленный в базу
данных, был хеширован. Для этого мы создадим интерактивный сеанс MongoDB, который позволит
нам запускать команды из базы данных.

В новом окне терминала выполните следующие команды:
$ mongo --port 27017

Запускается интерактивный сеанс MongoDB:

При работающем интерактивном сеансе выполните серию команд, чтобы переключиться на базу данных
планировщика и получить все пользовательские записи:
use planner
db.users.find({})

Предыдущая команда возвращает список пользователей, и теперь мы можем подтвердить, что пароль
пользователя был хеширован до того, как он был сохранен в базе данных. Теперь, когда мы
успешно создали компоненты для безопасного хранения паролей пользователей, давайте создадим
компоненты для создания и проверки JWTS.