Настройка тестовой среды
В предыдущем разделе мы узнали об основах тестирования, а также о том, что такое фикстуры.
Теперь мы проверим конечные точки для CRUD операций, а также  аутентификацию пользователей.
Чтобы протестировать наши электронные API, мы будем использовать httpx и установим 
библиотеку pytest-asyncio, чтобы мы могли протестировать наш асинхронный API.

Установите дополнительные библиотеки:
(venv)$ pip install httpx pytest-asyncio

Далее мы создадим файл конфигурации с именем pytest.ini. Добавьте в него следующий код:
[pytest]
asyncio_mode=True

Файл конфигурации читается при запуске pytest. Это автоматически заставляет pytest запускать
все тесты в асинхронном режиме.

Имея файл конфигурации, давайте создадим тестовый модуль conftest.py, который будет отвечать
за создание экземпляра нашего приложения, необходимого для тестовых файлов. В папке с тестами
создайте модуль conftest:
(venv)$ touch test/conftest.py

Мы начнем с импорта необходимых зависимостей в conftest.py:
import asyncio
import httpx
import pytest

from main import app
from database.connection import Settings
from models.events import Event
from models.users import User

В предыдущем блоке кода мы импортировали модули asyncio, httpx and pytest. Модуль asyncio 
будет использоваться для создания активного сеанса цикла, чтобы тесты выполнялись в одном потоке,
чтобы  избежать конфликтов. Тест httpx будет действовать как асинхронный клиент для
выполнения CRUD операций HTTP. Библиотека pytest необходима для определения фикстур.

Мы также испортировали приложение-экземпляр нашего приложения, а также модели и класс Settings.
Давайте определим фикстуру сеанса цикла:

@pytest.fixture(scope="session")
def event_loop():
	loop = asyncio.get_event_loop()
	yield loop
	loop.close()

Имея это в виду, давайте создадим новый экземпляр базы данных из класса Settings:

async def init_db():
	test_settings = Settings()
	test_settings.DATABASE_URL="mogodb://localhost:27017/testdb"
	
	await test_settings.initialize_database()

В предыдущем блоке кода мы определили новый DATABASE_URL, а также вызывали функцию инициализации,
определенную в главе 6 "Подлкючение к базеданных". Сейчас мы используем овую базу данных
testdb.

Наконец, давайте определим клиентскую фикстуру по умолчанию, которая возвращает экземпляр нашего 
приложения, работающего асинхронно черех httpx:

@pytest.fixture(scope="session")
async def default_client():
	await init_db()
	async with httpx.AsyncClient(a[[=app, base_url="http://app") as client:
		yield client
		#Client up resources
		await Event.find_all().delete()
		await User.find_all().delete()

В предыдущем блоке кода сначала инициализируется база данных, а приложение запускается как 
AsynClient, который остается активным до конца тестового сеанса. В конце сеанса тестирования
коллекция событий и пользователей стирается, чтобы убедиться, что база данных пуста перед
каждым запуском теста.

В этом разделе вы познакомились с шагами, связанными с настройкой вашей тестовой среды. 
В следующем разделе вы познакомитесь с процессом написнаия тестов для каждой конечной точки,
созданной в приложении.