Влидация тела запроса с использованием моделей Pydantic

In FastAPI тела запросов могут быть проверены, чтобы гарантировать отправку только определенных
данных. Это крайне важно, посокльку служит для очистки данных запросов и снижения рисков
вредоносных атак. Этот процесс известен как валидация.

Модель в FastAPI - это структурированный класс, который определяет, как следует получать или
анализировать данные. Модели создаются путем определния подкласса класса Basodel Pydantic.

Что такое Pydantic?

Pydantic - это бибилиотека Python, которая выполняет проверку данных с помощью аннотаций типа
Python.

Модели, когда они определены, используются в качестве подсказок типа для объектов тела
запроса и объектов запроса-ответа. В этой главе мы рассмотрим только использование моделей
Pydantic для тел запросов.

Примерная модель выглядит средующим образом:

from pydantic import BaseModel

class PacktBook(BaseModel):
	id:int
	Name:str
	Publishers:str
	Isbn:str

В предыдущем блоке кода выше мы определили модель PacktBook как подкласс класса BaseModel
Pydantic. Тип переменной, подсказанный классу PacktBook, может принимать только четыре
поля, как определено ранее. В следующих нескольких примерах мы видим, как Pydantic помогает
в проверке входных данных.

В нашем приложении todo ранее мы определили маршрут для добавления элемента в список todo.
В определении маршрута мы устанавливаем тело запроса в словарь:

async def add_todo(toodo:dict)->dict:
	'''

В примере запроса POST определенные данные были в следующем формате:
{
	"id": id,
	"item": item
}

Однако пустой словарь также мог быть отправлен без возврата какой-либо ошибки. Пользователь
может отправить запрос с телом, отличным от показанного ранее. Создание модели с требуемой
структурой тела запроса и присвоение ее в качестве типа телу запроса гарантирует, что будут
переданы только те поля данных, которые присутствуют в модели.

Например, чтобы в предыдущем примере поля содержались только в теле запроса, создайте новый
файл model.py и добавьте в него приведенный ниже код:

from Pydantic import BaseModel

class Todo(BaseMOde):	
	id:int
	item:str

В предыдущем блоке кода мы создали модель Pydantic, которая принимает только два поля:
id - целочисленное число
item - строка

Давайте продолжим и используем модельв маршруте POST. В api.py, импортируйте модель:
from model import Todo

Затем замените тип переменной тела запроса dict на Todo:

todo_list = []

@todo_router.post("/todo")
async def add_todo(todo: Todo)->dict:
	todo_list.append(todo)
	return {"message": "Todo added successfully"}

@todo_router.get("/todo")
async def retrieve_todos()->dict:
	return {"todos": todo_list}

Давайте проверим новый валидатор тела запроса, отправив пустой словарь в качестве тела запроса:

(venv) $ curl -X 'POST \
	'http://127.0.0.1:8000/todo' \
	-H 'accept: application/json' \
	-d '{
	}'

Получаем ответ, указывающий на отсутсвие поля id and item в теле запроса:
{
	"detail":[
		{
			"loc": [
				"body",	
				"id"
			],
			"msg": "field required"
			"type": "value_error.missing"
		},
		{
			"loc":[
				"body",	
				"item"
			],
			"msg": "field_required",
			"type": "value_error.missing"
		}
	]
}

Отправка запроса с правильными данными возвращает успешный ответ:

(venv) $ curl -X 'POST' \
	'http://127.0.0.1:8000/todo'\
	-H 'accept: application/json' \
	-H 'Content-Type: application/json' \
	-d '{
		"id":2,
		"item":"Validation models help with input types"
	}'

Вот ответ:
{
	"message": "Todo added successfully."
}

Вложенные модели

Модели Pydantic также могут быть вложенными, например, следующие:

class Item(BaseModel)	
	item:str
	status:str

class Todo(BaseModel)
	id:int
	item:Item

В результате задача типа Todo будет представлена следующим образом:
{
	"id":1,
	"item":{
		"item": "Nested models",
		"Status": "completed"
	}
}

Мы узнали, что такое модели, как из создавать и как их использовать. Мы будем использовать его
впоследствии в оставшихся частях этой книги. В следующем разделе рассмотрим параметры пути
и запроса.