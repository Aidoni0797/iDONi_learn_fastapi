Обработка ошибок

Ранее в этой главе мы узнали, что такое коды состояния и как они полезны для информирования 
клиента о состоянии запроса. Запросы могут возвращать ошибочные ответы, и эти ответы
могут быть некрасивыми или содержать недостаточную информацию о причине сбоя.

Ошибки запросов могут возникать из-за попыток доступа к несуществующим ресурсам, защищенным
страницам без достаточных разрешений и даже из-за ошибок сервера. Ошибки в FastAPI обрабатываются 
путем создания исключения с использованием класса FastAPI's HTTPException.

Что такое исключение HTTP?

Исключение HTTP - это событие, которое используется для указания на ошибку или проблему
в потоке запросов.

Класс HTTPException принимает три аргумента:
-status_code: Код состояния, который будет возвращен для этого сбоя
-detail: Сопроводительное сообщение для отправки клиенту
-headers: Необязательный параметр для ответов, требующих заголовков

В наших определениях маршрута задачи мы возвращаем сообщение, когда задача не может быть найдена.
Мы будем обновлять его, чтобы вызывать HTTPException. HTTPException позволяет нам вернуть
адекватный код ответа на ошибку.

В нашем текущем приложении получение несуществующей задачи возвращает код статуса ответа 200
вместо кода статуса ответа 404 на
https://127.0.0.1:8000/docs:

Обновляя маршруты для использования класса HTTPEception, мы можем возвращать соответствующие 
детали в нашем ответе. В todo.py, бновите маршруты для получения, обновления и удаления списка дел:

from fastapi import APIRouter, Path, HTTPException, status

@todo_router.get("/todo/{todo_id}")
async def get_single_todo(todo_id: int = Path(..., title="The ID of the todo to retrieve."))->dict:
	for todo in todo_list:
		if todo.id == todo_id:
			return{
				"todo": todo
			}
	raise HTTPException(
		status_code = status.HTTP_404_NOT_FOUND,
		detail="Todo with supplied ID doesn't  exist",
	)

@todo_router.put("/todo/{todo_id}")
async def update_todo(todo_data:TodoItem,todo_id:int=Path(...,title="The ID of the todo to be
updates."))->dict:
	for todo in todo_list:
		if todo.id == todo_id:
			todo.item = todo_data.item
			return {
				"message": "Todo updated successfully."
			}
	raise HTTPException(
		status_code = status.HTTP_404_NOT_FOUND,
		detail  = "Todo with supplied ID doesn't exist",
	)

@todo_router.delete("/todo/{todo_id}")
async def delete_single_todo(todo_id:int)->dict:
	for index in range(len(todo_list)):
		todo  = todo_list[index]
		if todo.id == todo_id:
			todo_list.pop(index)
			return {
				"message":"Todo deleted succesfully."
			}
	
	raise HTTPException(
		status_code = status.HTTP_404_NOT_FOUND,
		detail="Todo with supplied ID doesn't exist",
	)

Теперь давайте повторим попытку получения несуществующей задачи, чтобы убедиться, что 
возвращается правильный код ответа:

Наконец, мы можем объявить код состояния HTTP для переопределения кода состояния по умолчанию 
для успешных операций, добавив аргумент status_code в функцию декоратора:

@todo_router.post("/todo", status_code=201)
async def add_todo(todo:Todo)->dict:
	todo_list.append(todo)
	return {
		"message": "Todo added successfully."
	}

В этом разделе мы узнали, как возвращать правильные коды ответов клиентам, а также переопределять
код состояния по умолчанию. Также важно отметить, что код состояния успешный по умолчанию - 200.

Резюме
В этой главе мы узнали, что такое ответы и модели ответов и что подразумевается под
обработкой ошибок. Мы также узнали о кодах состояния HTTP и о том, почему важно их использовать.
Мы также создали модели ответа на основе знаний, которые мы получили о создании моделей
из предыдущей главы, и создали модель ответа, чтобы возвращать только элементы в списке дел
без их идентификаторов. Наконец, мы узнали об ошибках и обработке ошибок. Мы обновили наши
существующие маршруты, чтобы они возвращали правильный код ответа вместо стандартного кода
состояния 200.
В следующей главе вы познакомитесь с созданием шаблонов приложений FaspAPI с помощью Jinja.
Сначала вы познакомитесь с основами, необходимыми для запуска и работы с шаблонами Jinja,
после чего вы создадите пользовательский интерфейс, используя свои знания в области шаблонов
для нашего простого приложения.