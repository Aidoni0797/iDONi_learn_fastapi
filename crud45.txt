CRUD операции

В connection.py, создайте новый класс Database, который принимает модель в качестве
аргумента во время инициализации:

from pydantic import BaseSettings, BaseModel
from typing import Any, List, Optional

class Database:
	def __init__(self, model):
		self.model = model

Модель, передаваемая во время инициализации, представляет собой класс модели документа 
Event or User.

Создать
Давайте создадим метод в классе Database, чтобы добавить запись в коллекцию базы данных:

async def save(self, document)->None:
	await document.create()
		return

В этом блоке кода мы определили метод save для получения документа, который будет 
экземпляром документа, переданного в экземпляр Database в моммент создания экземпляра.

Читать
Давайте создадим методы для извлечения записи базы данных или всех записей, присутствующих
в коллекции базы данных:

async def get(self, id:PydanticObjectId)->Any:
	doc = await self.model.get(id)
	if doc:
		return doc
	return false

async def get_all(self)->List[Any]:
	docs = await self.model.find_all().to_list()
	return docs

Первый метод, get(), принимает идентификатор в качестве аргумента метода и возвращает
соответствующую запись из базы данных, в то время как метод get_all() не принимает
аргументов и возвращает список всех записей, имеющихся в базе данных.

Обновить
Давайте создадим метод для обработки процесса обновления существующей записи:

async def update(self, id:PydanticObjectId, body:BaseModel)->Any:
	doc_id = id
	des_body = body.dict()
	des_body = {k:v for k,v in des_body.items() if v is not None}
	update_query = {"$set":{
		field:value for field, value in des_body.items()
	}}
	doc = await self.get(doc_id)
	if not doc:
		return False
	await doc.update(update_query)
	return doc

В этом блоке кода метод update принимает ID и ответственную схему Pydantic, которая будет 
содержать поля, обновленные из запроса PUT отправленного клиентом. Обновленное тело запроса 
сначала анализируется в словаре, а затем фильтруется для удаления значений None.
Как только это будет сделано, он вставляется в запрос на обновление, который, наконец,
выполняется методом update() Beanie.

Удалиить
Наконец, давайте создадим метод для удаления записи из базы данных:

async def delte(self, id:PydanticObjectId)->bool:
	doc = await self.get(id)
	if not doc:
		return False
	await doc.delete()
	return True

В этом блоке кода метод проверяет, существует ли такая запись, прежде чем приступить к ее
удалению из базы данных.

ТЕперь, когда мы заполнили наш файл базы данных нужными методами, необходимыми для
выполнения CRUD операций, давайте также обновим маршруты.


